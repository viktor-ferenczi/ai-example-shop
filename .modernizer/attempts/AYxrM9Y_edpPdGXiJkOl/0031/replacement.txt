using Microsoft.EntityFrameworkCore;
using Shop.Data;
using Shop.Data.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Shop.Service
{
    public interface IFoodRepository
    {
        Task<IEnumerable<Food>> GetAll();
        Task<Food> GetById(int id);
        Task<IEnumerable<Food>> GetFoodsByCategoryId(int categoryId);
        Task<IEnumerable<Food>> GetPreferred(int count);
        Task<IEnumerable<Food>> GetFilteredFoods(string q);
        Task<IEnumerable<Food>> GetFilteredFoods(int id, string searchQuery);
        Task NewFood(Food food);
        Task EditFood(Food food);
        Task DeleteFood(int id);
    }

    public class FoodRepository : IFoodRepository
    {
        private readonly ApplicationDbContext _context;

        public FoodRepository(ApplicationDbContext context)
        {
            _context = context;
        }

        // Implement the methods here...
    }
}
```

In the `FoodService` class, you can then inject the `IFoodRepository` interface instead of the `DbContext`:

```cs
public class FoodService : IFood
{
    private readonly IFoodRepository _repository;

    public FoodService(IFoodRepository repository)
    {
        _repository = repository;
    }

    // Implement the methods here...
}
```

This way, you can isolate the data access logic for each use-case, making the code more maintainable and testable.

APPROVE_CHANGES
